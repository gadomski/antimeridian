{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"antimeridian","text":"<p>A Python module for correcting geometries that cross the antimeridian.</p>"},{"location":"#whats-the-antimeridian","title":"What's the antimeridian?","text":"<p>Also known as the 180th meridian, the antimeridian is the line of longitude on the opposite side of the world from the prime meridian. It can be either 180\u00b0 east or west.</p> <p></p>"},{"location":"#whats-the-problem","title":"What's the problem?","text":"<p>The GeoJSON specification recommends cutting geometries at the antimeridian. Many real-world geometries, however, don't follow this recommendation. It's very common to create a geometry in a projected coordinate system, then reproject that geometry to WGS84 to use it in GeoJSON. The reprojection process usually does not split the output geometry across the antimeridian, leading to invalid geometries. Here's a simple example, taken from a real-world Landsat STAC item:</p> <pre><code>{\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n        [\n            [\n                -179.70358951407547,\n                52.750507455036264\n            ],\n            [\n                179.96672360880183,\n                52.00163609753924\n            ],\n            [\n                -177.89334479610974,\n                50.62805205289558\n            ],\n            [\n                -179.9847165338706,\n                51.002602948712465\n            ],\n            [\n                -179.70358951407547,\n                52.750507455036264\n            ]\n        ]\n    ]\n}\n</code></pre> <p>As you can see, one corner of the polygon crosses the antimeridian, leading to an invalid item:</p> <p></p> <p>The issue also arises when geometries cross over a pole.</p>"},{"location":"#how-do-we-fix-it","title":"How do we fix it?","text":"<p>We use a relatively simple algorithm that splits the input polygon into segments. Each segment is defined by jumps of greater than 180\u00b0 longitude -- it's not a perfect heuristic, but tends to work for most real-world geometries we've encountered. Segments are then joined along the antimeridian. Segments that enclose the poles are constructed by adding points at the top of the antimeridian at both the east and the west longitudes.</p> <p>For more details, see the-algorithm.</p>"},{"location":"#examples","title":"Examples","text":"<p>Here's before and after pictures of some Sentinel 5p data. These are swath data that enclose both poles. In the before picture, you can see the strange artifacts created by the invalid geometry:</p> <p></p> <p>After correction, it's more clear that the data covers both poles:</p> <p></p> <p>Our library also handles splitting complex polygons that cross the antimeridian:</p> <p></p>"},{"location":"api/","title":"API documentation","text":"<p>Fix antimeridian crossings in GeoJSON objects and shapely geometries.</p>"},{"location":"api/#antimeridian.FixWindingWarning","title":"FixWindingWarning","text":"<p>               Bases: <code>AntimeridianWarning</code></p> <p>The input shape is wound clockwise (instead of counter-clockwise), so this package is reversing the winding order before fixing the shape.</p> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>class FixWindingWarning(AntimeridianWarning):\n    \"\"\"The input shape is wound clockwise (instead of counter-clockwise), so\n    this package is reversing the winding order before fixing the shape.\n    \"\"\"\n\n    MESSAGE = (\n        \"The exterior ring of this shape is wound \"\n        \"clockwise. Since this is a common error in real-world \"\n        \"geometries, this package is reversing the exterior coordinates of the \"\n        \"input shape before running its algorithm. If you know that your input \"\n        \"shape is correct (i.e. if your data encompasses both poles), pass \"\n        \"`fix_winding=False`.\"\n    )\n\n    @classmethod\n    def warn(cls) -&gt; None:\n        warnings.warn(cls.MESSAGE, cls, stacklevel=2)\n</code></pre>"},{"location":"api/#antimeridian.GeoInterface","title":"GeoInterface","text":"<p>               Bases: <code>Protocol</code></p> <p>A simple protocol for things that have a <code>__geo_interface__</code> method.</p> <p>The <code>__geo_interface__</code> protocol is described here, and is used within shapely to extract geometries from objects.</p> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>class GeoInterface(Protocol):\n    \"\"\"A simple protocol for things that have a `__geo_interface__` method.\n\n    The `__geo_interface__` protocol is described\n    [here](https://gist.github.com/sgillies/2217756&gt;), and is used within\n    [shapely](https://shapely.readthedocs.io/en/stable/manual.html) to extract\n    geometries from objects.\n    \"\"\"\n\n    @property\n    def __geo_interface__(self) -&gt; Dict[str, Any]: ...\n</code></pre>"},{"location":"api/#antimeridian.bbox","title":"bbox","text":"<pre><code>bbox(\n    shape: Dict[str, Any] | GeoInterface,\n    force_over_antimeridian: bool = False,\n) -&gt; List[float]\n</code></pre> <p>Calculates a GeoJSON-spec conforming bounding box for a shape.</p> <p>Per the GeoJSON spec, an antimeridian-spanning bounding box should have its larger longitude as its first bounding box coordinate.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>Dict[str, Any] | GeoInterface</code>)           \u2013            <p>The polygon or multipolygon for which to calculate the bounding box.</p> </li> <li> <code>force_over_antimeridian</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Force the bounding box to be over the antimeridian.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>List[float]</code>           \u2013            <p>List[float]: The bounding box.</p> </li> </ul> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def bbox(\n    shape: Dict[str, Any] | GeoInterface, force_over_antimeridian: bool = False\n) -&gt; List[float]:\n    \"\"\"Calculates a GeoJSON-spec conforming bounding box for a shape.\n\n    Per the [GeoJSON\n    spec](https://datatracker.ietf.org/doc/html/rfc7946#section-5.2), an\n    antimeridian-spanning bounding box should have its larger longitude as its\n    first bounding box coordinate.\n\n    Args:\n        shape: The polygon or multipolygon for which to calculate the bounding box.\n        force_over_antimeridian: Force the bounding box to be over the antimeridian.\n\n    Returns:\n        List[float]: The bounding box.\n    \"\"\"\n    geom = shapely.geometry.shape(shape)\n    if geom.geom_type == \"Polygon\":\n        return list(geom.bounds)\n    elif geom.geom_type == \"MultiPolygon\":\n        crosses_antimeridian = False\n        xmins = list()\n        ymin = 90\n        xmaxs = list()\n        ymax = -90\n        for polygon in geom.geoms:\n            bounds = polygon.bounds\n            xmins.append(bounds[0])\n            if bounds[1] &lt; ymin:\n                ymin = bounds[1]\n            xmaxs.append(bounds[2])\n            if bounds[3] &gt; ymax:\n                ymax = bounds[3]\n            if is_coincident_to_antimeridian(polygon) and not (\n                bounds[0] == -180 and bounds[2] == 180\n            ):\n                crosses_antimeridian = True\n\n        if crosses_antimeridian or force_over_antimeridian:\n            return [max(xmins), ymin, min(xmaxs), ymax]\n        else:\n            return [min(xmins), ymin, max(xmaxs), ymax]\n    else:\n        raise ValueError(\n            f\"unsupported geom_type for bbox calculation: {geom.geom_type}\"\n        )\n</code></pre>"},{"location":"api/#antimeridian.centroid","title":"centroid","text":"<pre><code>centroid(shape: Dict[str, Any] | GeoInterface) -&gt; Point\n</code></pre> <p>Calculates the centroid for a polygon or multipolygon.</p> <p>Polygons are easy, we just use shapely.centroid. For multi-polygons, the antimeridian is taken into account by calculating the centroid from an identical multi-polygon with coordinates in [0, 360).</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>Dict[str, Any] | GeoInterface</code>)           \u2013            <p>The polygon or multipolygon for which to calculate the centroid.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Point</code> (              <code>Point</code> )          \u2013            <p>The centroid.</p> </li> </ul> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def centroid(shape: Dict[str, Any] | GeoInterface) -&gt; Point:\n    \"\"\"Calculates the centroid for a polygon or multipolygon.\n\n    Polygons are easy, we just use [shapely.centroid][]. For\n    multi-polygons, the antimeridian is taken into account by calculating the\n    centroid from an identical multi-polygon with coordinates in [0, 360).\n\n    Args:\n        shape: The polygon or multipolygon for which to calculate the centroid.\n\n    Returns:\n        Point: The centroid.\n    \"\"\"\n    # Inspired by\n    # https://github.com/stactools-packages/sentinel2/blob/f90f5fa006459e9bb59bfd327d9199e5259ec4a7/src/stactools/sentinel2/stac.py#L192-L208\n    geom = shapely.geometry.shape(shape)\n    if geom.geom_type == \"Polygon\":\n        return cast(Point, geom.centroid)\n    elif geom.geom_type == \"MultiPolygon\":\n        geoms = list()\n        for component in geom.geoms:\n            if any(c[0] &lt; 0 for c in component.exterior.coords):\n                geoms.append(shapely.affinity.translate(component, xoff=+360))\n            else:\n                geoms.append(component)\n        centroid = cast(\n            Point, shapely.validation.make_valid(MultiPolygon(geoms)).centroid\n        )\n        if centroid.x &gt; 180:\n            centroid = Point(centroid.x - 360, centroid.y)\n        return centroid\n    else:\n        raise ValueError(\n            f\"unsupported geom_type for centroid calculation: {geom.geom_type}\"\n        )\n</code></pre>"},{"location":"api/#antimeridian.fix_geojson","title":"fix_geojson","text":"<pre><code>fix_geojson(\n    geojson: Dict[str, Any],\n    *,\n    force_north_pole: bool = False,\n    force_south_pole: bool = False,\n    fix_winding: bool = True,\n    great_circle: bool = True,\n    reverse: bool = False,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Fixes a GeoJSON object that crosses the antimeridian.</p> <p>If the object does not cross the antimeridian, it is returned unchanged.</p> <p>See antimeridian.fix_polygon for a description of the <code>force_north_pole</code> <code>force_south_pole</code> and <code>fix_winding</code> arguments.</p> <p>Parameters:</p> <ul> <li> <code>geojson</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>A GeoJSON object as a dictionary</p> </li> <li> <code>force_north_pole</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the polygon crosses the antimeridian, force the joined segments to enclose the north pole.</p> </li> <li> <code>force_south_pole</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the polygon crosses the antimeridian, force the joined segments to enclose the south pole.</p> </li> <li> <code>fix_winding</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If the polygon is wound clockwise, reverse its coordinates before applying the algorithm.</p> </li> <li> <code>great_circle</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Compute meridian crossings on the sphere rather than using 2D geometry.</p> </li> <li> <code>reverse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Reverse the coordinates before fixing.</p> </li> </ul> Return <p>The same GeoJSON with a fixed geometry or geometries</p> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def fix_geojson(\n    geojson: Dict[str, Any],\n    *,\n    force_north_pole: bool = False,\n    force_south_pole: bool = False,\n    fix_winding: bool = True,\n    great_circle: bool = True,\n    reverse: bool = False,\n) -&gt; Dict[str, Any]:\n    \"\"\"Fixes a GeoJSON object that crosses the antimeridian.\n\n    If the object does not cross the antimeridian, it is returned unchanged.\n\n    See [antimeridian.fix_polygon][] for a description of the `force_north_pole`\n    `force_south_pole` and `fix_winding` arguments.\n\n    Args:\n        geojson: A GeoJSON object as a dictionary\n        force_north_pole: If the polygon crosses the antimeridian, force the\n            joined segments to enclose the north pole.\n        force_south_pole: If the polygon crosses the antimeridian, force the\n            joined segments to enclose the south pole.\n        fix_winding: If the polygon is wound clockwise, reverse its\n            coordinates before applying the algorithm.\n        great_circle: Compute meridian crossings on the sphere rather than\n            using 2D geometry.\n        reverse: Reverse the coordinates before fixing.\n\n    Return:\n        The same GeoJSON with a fixed geometry or geometries\n    \"\"\"\n    type_ = geojson.get(\"type\", None)\n    if type_ is None:\n        raise ValueError(\"no 'type' field found in GeoJSON\")\n    elif type_ == \"Feature\":\n        geometry = geojson.get(\"geometry\", None)\n        if geometry is None:\n            raise ValueError(\"no 'geometry' field found in GeoJSON Feature\")\n        geojson[\"geometry\"] = fix_shape(\n            geometry,\n            force_north_pole=force_north_pole,\n            force_south_pole=force_south_pole,\n            fix_winding=fix_winding,\n            great_circle=great_circle,\n            reverse=reverse,\n        )\n        return geojson\n    elif type_ == \"FeatureCollection\":\n        features = geojson.get(\"features\", None)\n        if features is None:\n            raise ValueError(\"no 'features' field found in GeoJSON FeatureCollection\")\n        for i, feature in enumerate(features):\n            features[i] = fix_geojson(\n                feature,\n                force_north_pole=force_north_pole,\n                force_south_pole=force_south_pole,\n                fix_winding=fix_winding,\n                great_circle=great_circle,\n                reverse=reverse,\n            )\n        geojson[\"features\"] = features\n        return geojson\n    else:\n        return fix_shape(\n            geojson,\n            force_north_pole=force_north_pole,\n            force_south_pole=force_south_pole,\n            fix_winding=fix_winding,\n            great_circle=great_circle,\n            reverse=reverse,\n        )\n</code></pre>"},{"location":"api/#antimeridian.fix_line_string","title":"fix_line_string","text":"<pre><code>fix_line_string(\n    line_string: LineString, great_circle: bool\n) -&gt; Union[LineString, MultiLineString]\n</code></pre> <p>Fixes a shapely.LineString.</p> <p>Parameters:</p> <ul> <li> <code>line_string</code>               (<code>LineString</code>)           \u2013            <p>The input line string</p> </li> <li> <code>great_circle</code>               (<code>bool</code>)           \u2013            <p>Compute meridian crossings on the sphere rather than using 2D geometry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[LineString, MultiLineString]</code>           \u2013            <p>The fixed line string, either as a single line string or a multi-line</p> </li> <li> <code>Union[LineString, MultiLineString]</code>           \u2013            <p>string (if it was split)</p> </li> </ul> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def fix_line_string(\n    line_string: LineString, great_circle: bool\n) -&gt; Union[LineString, MultiLineString]:\n    \"\"\"Fixes a [shapely.LineString][].\n\n    Args:\n        line_string: The input line string\n        great_circle: Compute meridian crossings on the sphere rather than\n            using 2D geometry.\n\n    Returns:\n        The fixed line string, either as a single line string or a multi-line\n        string (if it was split)\n    \"\"\"\n    segments = segment(list(line_string.coords), great_circle)\n    if not segments:\n        return line_string\n    else:\n        return MultiLineString(segments)\n</code></pre>"},{"location":"api/#antimeridian.fix_multi_line_string","title":"fix_multi_line_string","text":"<pre><code>fix_multi_line_string(\n    multi_line_string: MultiLineString, great_circle: bool\n) -&gt; MultiLineString\n</code></pre> <p>Fixes a shapely.MultiLineString.</p> <p>Parameters:</p> <ul> <li> <code>multi_line_string</code>               (<code>MultiLineString</code>)           \u2013            <p>The input multi line string</p> </li> <li> <code>great_circle</code>               (<code>bool</code>)           \u2013            <p>Compute meridian crossings on the sphere rather than using 2D geometry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MultiLineString</code>           \u2013            <p>The fixed multi line string</p> </li> </ul> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def fix_multi_line_string(\n    multi_line_string: MultiLineString, great_circle: bool\n) -&gt; MultiLineString:\n    \"\"\"Fixes a [shapely.MultiLineString][].\n\n    Args:\n        multi_line_string: The input multi line string\n        great_circle: Compute meridian crossings on the sphere rather than\n            using 2D geometry.\n\n    Returns:\n        The fixed multi line string\n    \"\"\"\n    line_strings = list()\n    for line_string in multi_line_string.geoms:\n        fixed = fix_line_string(line_string, great_circle)\n        if isinstance(fixed, LineString):\n            line_strings.append(fixed)\n        else:\n            line_strings.extend(fixed.geoms)\n    return MultiLineString(line_strings)\n</code></pre>"},{"location":"api/#antimeridian.fix_multi_polygon","title":"fix_multi_polygon","text":"<pre><code>fix_multi_polygon(\n    multi_polygon: MultiPolygon,\n    *,\n    force_north_pole: bool = False,\n    force_south_pole: bool = False,\n    fix_winding: bool = True,\n    great_circle: bool = True,\n) -&gt; MultiPolygon\n</code></pre> <p>Fixes a shapely.MultiPolygon.</p> <p>See antimeridian.fix_polygon for a description of the <code>force_north_pole</code> <code>force_south_pole</code> and <code>fix_winding</code> arguments.</p> <p>Parameters:</p> <ul> <li> <code>multi_polygon</code>               (<code>MultiPolygon</code>)           \u2013            <p>The multi-polygon</p> </li> <li> <code>force_north_pole</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the polygon crosses the antimeridian, force the joined segments to enclose the north pole.</p> </li> <li> <code>force_south_pole</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the polygon crosses the antimeridian, force the joined segments to enclose the south pole.</p> </li> <li> <code>fix_winding</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If the polygon is wound clockwise, reverse its coordinates before applying the algorithm.</p> </li> <li> <code>great_circle</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Compute meridian crossings on the sphere rather than using 2D geometry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>MultiPolygon</code>           \u2013            <p>The fixed multi-polygon</p> </li> </ul> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def fix_multi_polygon(\n    multi_polygon: MultiPolygon,\n    *,\n    force_north_pole: bool = False,\n    force_south_pole: bool = False,\n    fix_winding: bool = True,\n    great_circle: bool = True,\n) -&gt; MultiPolygon:\n    \"\"\"Fixes a [shapely.MultiPolygon][].\n\n    See [antimeridian.fix_polygon][] for a description of the `force_north_pole`\n    `force_south_pole` and `fix_winding` arguments.\n\n    Args:\n        multi_polygon: The multi-polygon\n        force_north_pole: If the polygon crosses the antimeridian, force the\n            joined segments to enclose the north pole.\n        force_south_pole: If the polygon crosses the antimeridian, force the\n            joined segments to enclose the south pole.\n        fix_winding: If the polygon is wound clockwise, reverse its\n            coordinates before applying the algorithm.\n        great_circle: Compute meridian crossings on the sphere rather than\n            using 2D geometry.\n\n    Returns:\n        The fixed multi-polygon\n    \"\"\"\n    polygons = list()\n    for polygon in multi_polygon.geoms:\n        polygons += fix_polygon_to_list(\n            polygon,\n            force_north_pole=force_north_pole,\n            force_south_pole=force_south_pole,\n            fix_winding=fix_winding,\n            great_circle=great_circle,\n        )\n    return MultiPolygon(polygons)\n</code></pre>"},{"location":"api/#antimeridian.fix_polygon","title":"fix_polygon","text":"<pre><code>fix_polygon(\n    polygon: Polygon,\n    *,\n    force_north_pole: bool = False,\n    force_south_pole: bool = False,\n    fix_winding: bool = True,\n    great_circle: bool = True,\n) -&gt; Union[Polygon, MultiPolygon]\n</code></pre> <p>Fixes a shapely.Polygon.</p> <p>If the input polygon is wound clockwise, it will be fixed to be wound counterclockwise unless <code>fix_winding</code> is <code>False</code> in which case it will be corrected by adding a counterclockwise polygon from (-180, -90) to (180, 90) as its exterior.</p> <p>In rare cases, the underlying algorithm might need a little help to fix the polygon. For example, a polygon that just barely crosses over a pole might have very few points at high latitudes, leading to ambiguous antimeridian crossing points and invalid geometries. We provide two flags, <code>force_north_pole</code> and <code>force_south_pole</code> for those cases. Most users can ignore these flags.</p> <p>If either <code>force_north_pole</code> or <code>force_south_pole</code> is <code>True</code> <code>fix_winding</code> is set to <code>False</code></p> <p>Parameters:</p> <ul> <li> <code>polygon</code>               (<code>Polygon</code>)           \u2013            <p>The input polygon</p> </li> <li> <code>force_north_pole</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the polygon crosses the antimeridian, force the joined segments to enclose the north pole.</p> </li> <li> <code>force_south_pole</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the polygon crosses the antimeridian, force the joined segments to enclose the south pole.</p> </li> <li> <code>fix_winding</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If the polygon is wound clockwise, reverse its coordinates before applying the algorithm.</p> </li> <li> <code>great_circle</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Compute meridian crossings on the sphere rather than using 2D geometry.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Union[Polygon, MultiPolygon]</code>           \u2013            <p>The fixed polygon, either as a single polygon or a multi-polygon (if it was split)</p> </li> </ul> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def fix_polygon(\n    polygon: Polygon,\n    *,\n    force_north_pole: bool = False,\n    force_south_pole: bool = False,\n    fix_winding: bool = True,\n    great_circle: bool = True,\n) -&gt; Union[Polygon, MultiPolygon]:\n    \"\"\"Fixes a [shapely.Polygon][].\n\n    If the input polygon is wound clockwise, it will be fixed to be wound\n    counterclockwise _unless_ `fix_winding` is `False` in which case it\n    will be corrected by adding a counterclockwise polygon from (-180, -90) to\n    (180, 90) as its exterior.\n\n    In rare cases, the underlying algorithm might need a little help to fix the polygon.\n    For example, a polygon that just barely crosses over a pole might have very\n    few points at high latitudes, leading to ambiguous antimeridian crossing\n    points and invalid geometries. We provide two flags, `force_north_pole`\n    and `force_south_pole` for those cases. Most users can ignore these\n    flags.\n\n    If either `force_north_pole` or `force_south_pole` is `True`\n    `fix_winding` is set to `False`\n\n    Args:\n        polygon: The input polygon\n        force_north_pole: If the polygon crosses the antimeridian, force the\n            joined segments to enclose the north pole.\n        force_south_pole: If the polygon crosses the antimeridian, force the\n            joined segments to enclose the south pole.\n        fix_winding: If the polygon is wound clockwise, reverse its\n            coordinates before applying the algorithm.\n        great_circle: Compute meridian crossings on the sphere rather than\n            using 2D geometry.\n\n    Returns:\n        The fixed polygon, either as a single polygon or a multi-polygon (if it\n            was split)\n    \"\"\"\n    if force_north_pole or force_south_pole:\n        fix_winding = False\n    polygons = fix_polygon_to_list(\n        polygon,\n        force_north_pole=force_north_pole,\n        force_south_pole=force_south_pole,\n        fix_winding=fix_winding,\n        great_circle=great_circle,\n    )\n    if len(polygons) == 1:\n        polygon = polygons[0]\n        if shapely.is_ccw(polygon.exterior):\n            return polygon\n        else:\n            return Polygon(\n                [(-180, 90), (-180, -90), (180, -90), (180, 90)],\n                [polygon.exterior.coords],\n            )\n    else:\n        return MultiPolygon(polygons)\n</code></pre>"},{"location":"api/#antimeridian.fix_shape","title":"fix_shape","text":"<pre><code>fix_shape(\n    shape: Dict[str, Any] | GeoInterface,\n    *,\n    force_north_pole: bool = False,\n    force_south_pole: bool = False,\n    fix_winding: bool = True,\n    great_circle: bool = True,\n    reverse: bool = False,\n) -&gt; Dict[str, Any]\n</code></pre> <p>Fixes a shape that crosses the antimeridian.</p> <p>See antimeridian.fix_polygon for a description of the <code>force_north_pole</code> <code>force_south_pole</code> and <code>fix_winding</code> arguments.</p> <p>Parameters:</p> <ul> <li> <code>shape</code>               (<code>Dict[str, Any] | GeoInterface</code>)           \u2013            <p>A polygon, multi-polygon, line string, or multi-line string, either as a dictionary or as a antimeridian.GeoInterface. Uses shapely.geometry.shape under the hood.</p> </li> <li> <code>force_north_pole</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the polygon crosses the antimeridian, force the joined segments to enclose the north pole.</p> </li> <li> <code>force_south_pole</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>If the polygon crosses the antimeridian, force the joined segments to enclose the south pole.</p> </li> <li> <code>fix_winding</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>If the polygon is wound clockwise, reverse its coordinates before applying the algorithm.</p> </li> <li> <code>great_circle</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Compute meridian crossings on the sphere rather than using 2D geometry.</p> </li> <li> <code>reverse</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Reverse the coordinates before fixing.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Dict[str, Any]</code>           \u2013            <p>The fixed shape as a dictionary</p> </li> </ul> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def fix_shape(\n    shape: Dict[str, Any] | GeoInterface,\n    *,\n    force_north_pole: bool = False,\n    force_south_pole: bool = False,\n    fix_winding: bool = True,\n    great_circle: bool = True,\n    reverse: bool = False,\n) -&gt; Dict[str, Any]:\n    \"\"\"Fixes a shape that crosses the antimeridian.\n\n    See [antimeridian.fix_polygon][] for a description of the `force_north_pole`\n    `force_south_pole` and `fix_winding` arguments.\n\n    Args:\n        shape: A polygon, multi-polygon, line string, or multi-line string,\n            either as a dictionary or as a [antimeridian.GeoInterface][]. Uses\n            [shapely.geometry.shape][] under the hood.\n        force_north_pole: If the polygon crosses the antimeridian, force the\n            joined segments to enclose the north pole.\n        force_south_pole: If the polygon crosses the antimeridian, force the\n            joined segments to enclose the south pole.\n        fix_winding: If the polygon is wound clockwise, reverse its\n            coordinates before applying the algorithm.\n        great_circle: Compute meridian crossings on the sphere rather than\n            using 2D geometry.\n        reverse: Reverse the coordinates before fixing.\n\n    Returns:\n        The fixed shape as a dictionary\n    \"\"\"\n    geom = shapely.geometry.shape(shape)\n    if reverse:\n        geom = geom.reverse()\n    if geom.geom_type == \"Polygon\":\n        return cast(\n            Dict[str, Any],\n            shapely.geometry.mapping(\n                fix_polygon(\n                    geom,\n                    force_north_pole=force_north_pole,\n                    force_south_pole=force_south_pole,\n                    fix_winding=fix_winding,\n                    great_circle=great_circle,\n                )\n            ),\n        )\n    elif geom.geom_type == \"MultiPolygon\":\n        return cast(\n            Dict[str, Any],\n            shapely.geometry.mapping(\n                fix_multi_polygon(\n                    geom,\n                    force_north_pole=force_north_pole,\n                    force_south_pole=force_south_pole,\n                    fix_winding=fix_winding,\n                    great_circle=great_circle,\n                )\n            ),\n        )\n    elif geom.geom_type == \"LineString\":\n        return cast(\n            Dict[str, Any],\n            shapely.geometry.mapping(fix_line_string(geom, great_circle)),\n        )\n    elif geom.geom_type == \"MultiLineString\":\n        return cast(\n            Dict[str, Any],\n            shapely.geometry.mapping(fix_multi_line_string(geom, great_circle)),\n        )\n    else:\n        raise ValueError(f\"unsupported geom_type: {geom.geom_type}\")\n</code></pre>"},{"location":"api/#antimeridian.segment_geojson","title":"segment_geojson","text":"<pre><code>segment_geojson(\n    geojson: Dict[str, Any], great_circle: bool\n) -&gt; MultiLineString\n</code></pre> <p>Segments a GeoJSON object into a MultiLineString.</p> <p>If the object does not cross the antimeridian, its exterior and interior line strings are returned unchanged.</p> <p>Parameters:</p> <ul> <li> <code>geojson</code>               (<code>Dict[str, Any]</code>)           \u2013            <p>A GeoJSON object as a dictionary</p> </li> <li> <code>great_circle</code>               (<code>bool</code>)           \u2013            <p>Compute meridian crossings on the sphere rather than using 2D geometry.</p> </li> </ul> Return <p>A MutliLineString of segments.</p> Source code in <code>src/antimeridian/_implementation.py</code> <pre><code>def segment_geojson(geojson: Dict[str, Any], great_circle: bool) -&gt; MultiLineString:\n    \"\"\"Segments a GeoJSON object into a MultiLineString.\n\n    If the object does not cross the antimeridian, its exterior and interior\n    line strings are returned unchanged.\n\n    Args:\n        geojson: A GeoJSON object as a dictionary\n        great_circle: Compute meridian crossings on the sphere rather than\n            using 2D geometry.\n\n    Return:\n        A MutliLineString of segments.\n    \"\"\"\n    type_ = geojson.get(\"type\", None)\n    if type_ is None:\n        raise ValueError(\"no 'type' field found in GeoJSON\")\n    elif type_ == \"Feature\":\n        geometry = geojson.get(\"geometry\", None)\n        if geometry is None:\n            raise ValueError(\"no 'geometry' field found in GeoJSON Feature\")\n        return MultiLineString(segment_shape(geometry, great_circle))\n    elif type_ == \"FeatureCollection\":\n        features = geojson.get(\"features\", None)\n        if features is None:\n            raise ValueError(\"no 'features' field found in GeoJSON FeatureCollection\")\n        segments = list()\n        for feature in features:\n            segments.extend(segment_geojson(feature, great_circle))\n        return MultiLineString(segments)\n    else:\n        return MultiLineString(segment_shape(geojson, great_circle))\n</code></pre>"},{"location":"cli/","title":"Command line interface","text":"<p>The antimeridian CLI (command line interface) takes a GeoJSON file path as its input, and outputs a fixed GeoJSON dictionary to standard output.</p>"},{"location":"cli/#installation","title":"Installation","text":"<p>Install with pip:</p> <pre><code>python -m pip install 'antimeridian[cli]'\n</code></pre>"},{"location":"cli/#usage","title":"Usage","text":""},{"location":"cli/#cli","title":"cli","text":"<p>Usage:</p> <pre><code>cli [OPTIONS] COMMAND [ARGS]...\n</code></pre> <p>Options:</p> <pre><code>  --help  Show this message and exit.\n</code></pre>"},{"location":"cli/#bbox","title":"bbox","text":"<p>Calculates the antimeridian-spanning bbox for the input geometry.</p> <p>Usage:</p> <pre><code>cli bbox [OPTIONS] [INFILE]\n</code></pre> <p>Options:</p> <pre><code>  -f, --force-over-antimeridian BOOLEAN\n                                  Force the bbox to be antimeridian-spanning\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#fix","title":"fix","text":"<p>Fixes any antimeridian problems a GeoJSON file</p> <p>Writes the fixed GeoJSON to standard output. If the filename is <code>-</code> the input GeoJSON is read from standard input.</p> <p>Usage:</p> <pre><code>cli fix [OPTIONS] [INFILE]\n</code></pre> <p>Options:</p> <pre><code>  --force-north-pole              Force the fixed polygon to enclose the north\n                                  pole\n  --force-south-pole              Force the fixed polygon to enclose the south\n                                  pole\n  --fix-winding / --no-fix-winding\n                                  Automatically fix clockwise polygons to be\n                                  the correct counterclockwise winding order\n                                  [default: fix-winding]\n  --great-circle / --no-great-circle\n                                  Compute meridian crossings on the sphere\n                                  rather than using 2D geometry  [default:\n                                  great-circle]\n  --reverse                       Reverse the coordinates before fixing\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"cli/#segment","title":"segment","text":"<p>Segments the exterior coordinates of a GeoJSON file</p> <p>Prints the resulting MultiLineString to standard output. Useful mostly for debugging problems with <code>fix</code>.</p> <p>Usage:</p> <pre><code>cli segment [OPTIONS] [INFILE]\n</code></pre> <p>Options:</p> <pre><code>  -i, --index INTEGER             Return the single LineString at this index\n  --great-circle / --no-great-circle\n                                  Compute meridian crossings on the sphere\n                                  rather than using 2D geometry  [default:\n                                  great-circle]\n  --help                          Show this message and exit.\n</code></pre>"},{"location":"comparison/","title":"Comparison with WRAPDATELINE","text":"In\u00a0[\u00a0]: Copied! <pre>import json\nimport subprocess\n\nimport shapely.geometry\nfrom cartopy.crs import PlateCarree\nfrom matplotlib import pyplot\n\n\ndef plot(name: str) -&gt; None:\n    path = f\"../tests/data/input/{name}.json\"\n    antimeridian_output = shapely.geometry.shape(\n        json.loads(subprocess.check_output([\"antimeridian\", \"fix\", path]))\n    )\n    ogr2ogr_feature_collection = json.loads(\n        subprocess.check_output(\n            [\n                \"ogr2ogr\",\n                \"-q\",\n                \"-f\",\n                \"GeoJSON\",\n                \"-wrapdateline\",\n                \"-datelineoffset\",\n                \"180\",\n                \"/vsistdout/\",\n                path,\n            ],\n        )\n    )\n    assert len(ogr2ogr_feature_collection[\"features\"]) == 1\n    ogr2ogr_output = shapely.geometry.shape(\n        ogr2ogr_feature_collection[\"features\"][0][\"geometry\"]\n    )\n\n    figure = pyplot.figure()\n\n    axes = figure.add_subplot(121, projection=PlateCarree())\n    axes.set_title(f\"{name} (antimeridian)\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(\n        antimeridian_output, crs=PlateCarree(), color=\"coral\", alpha=0.7\n    )\n\n    axes = figure.add_subplot(122, projection=PlateCarree())\n    axes.set_title(f\"{name} (ogr2ogr)\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(ogr2ogr_output, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n\nfor name in [\n    \"split\",\n    \"multi-split\",\n    \"complex-split\",\n    \"two-holes\",\n    \"line\",\n    \"issues-124\",\n]:\n    plot(name)\n</pre> import json import subprocess  import shapely.geometry from cartopy.crs import PlateCarree from matplotlib import pyplot   def plot(name: str) -&gt; None:     path = f\"../tests/data/input/{name}.json\"     antimeridian_output = shapely.geometry.shape(         json.loads(subprocess.check_output([\"antimeridian\", \"fix\", path]))     )     ogr2ogr_feature_collection = json.loads(         subprocess.check_output(             [                 \"ogr2ogr\",                 \"-q\",                 \"-f\",                 \"GeoJSON\",                 \"-wrapdateline\",                 \"-datelineoffset\",                 \"180\",                 \"/vsistdout/\",                 path,             ],         )     )     assert len(ogr2ogr_feature_collection[\"features\"]) == 1     ogr2ogr_output = shapely.geometry.shape(         ogr2ogr_feature_collection[\"features\"][0][\"geometry\"]     )      figure = pyplot.figure()      axes = figure.add_subplot(121, projection=PlateCarree())     axes.set_title(f\"{name} (antimeridian)\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(         antimeridian_output, crs=PlateCarree(), color=\"coral\", alpha=0.7     )      axes = figure.add_subplot(122, projection=PlateCarree())     axes.set_title(f\"{name} (ogr2ogr)\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(ogr2ogr_output, crs=PlateCarree(), color=\"coral\", alpha=0.7)   for name in [     \"split\",     \"multi-split\",     \"complex-split\",     \"two-holes\",     \"line\",     \"issues-124\", ]:     plot(name) <pre>ERROR 1: TopologyException: side location conflict at 234.90917500381769 14.76580303507545. This can occur if the input geometry is invalid.\nERROR 1: TopologyException: side location conflict at 234.90917500381769 14.76580303507545. This can occur if the input geometry is invalid.\n</pre>"},{"location":"comparison/#comparison-with-wrapdateline","title":"Comparison with WRAPDATELINE\u00b6","text":"<p>GDAL has the <code>WRAPDATELINE</code> option to deal with geometries that cross the antimeridian, which was added to <code>ogr2ogr</code> in v1.7.0 via the <code>-wrapdateline</code> flag. As demonstrated below, <code>antimeridian</code> has more-or-less the same behavior but includes a couple of modifications and improvements:</p> <ul> <li><code>antimeridian</code> outputs the same geometry type as the input. <code>ogr2ogr</code> outputs a <code>FeatureCollection</code>.</li> <li><code>ogr2ogr</code> requires tuning via the <code>-datelineoffset</code> flag. To get corrected outputs from <code>ogr2ogr</code>, we had to set the <code>-datelineoffset</code> to <code>180</code> (the default is <code>10</code>).</li> <li><code>antimeridian</code> handles the poles (usually).</li> </ul>"},{"location":"examples/","title":"Examples","text":"In\u00a0[1]: Copied! <pre>import json\nimport warnings\nfrom pathlib import Path\nfrom typing import Any, Dict, Optional\n\nimport shapely.geometry\nfrom cartopy.crs import Mollweide, PlateCarree\nfrom cartopy.io import DownloadWarning\nfrom matplotlib import pyplot\n\nimport antimeridian\n\nwarnings.filterwarnings(\"ignore\", category=DownloadWarning)\n\n\ndef read_json(path: Path) -&gt; Dict[str, Any]:\n    with open(path) as f:\n        return json.load(f)\n\n\ndef plot(name: str, fix_winding: bool = True, suptitle: Optional[str] = None) -&gt; None:\n    data = read_json(f\"../tests/data/input/{name}.json\")\n    input = shapely.geometry.shape(data)\n    output = shapely.geometry.shape(\n        antimeridian.fix_geojson(data, fix_winding=fix_winding)\n    )\n\n    if suptitle is None:\n        suptitle = name\n\n    figure = pyplot.figure()\n    figure.suptitle(suptitle)\n\n    axes = figure.add_subplot(2, 2, 1, projection=PlateCarree())\n    axes.set_title(\"Original in PlateCarree\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(input, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n    axes = figure.add_subplot(2, 2, 2, projection=PlateCarree())\n    axes.set_title(\"Fixed in PlateCarree\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(output, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n    axes = figure.add_subplot(2, 2, 3, projection=Mollweide(central_longitude=180))\n    axes.set_title(\"Original in Mollweide\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(input, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n    axes = figure.add_subplot(2, 2, 4, projection=Mollweide(central_longitude=180))\n    axes.set_title(\"Fixed in Mollweide\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(output, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n    pyplot.show()\n\n\nfor name in [\n    \"split\",\n    \"north-pole\",\n    \"complex-split\",\n    \"multi-split\",\n    \"overlap\",\n]:\n    plot(name)\n</pre> import json import warnings from pathlib import Path from typing import Any, Dict, Optional  import shapely.geometry from cartopy.crs import Mollweide, PlateCarree from cartopy.io import DownloadWarning from matplotlib import pyplot  import antimeridian  warnings.filterwarnings(\"ignore\", category=DownloadWarning)   def read_json(path: Path) -&gt; Dict[str, Any]:     with open(path) as f:         return json.load(f)   def plot(name: str, fix_winding: bool = True, suptitle: Optional[str] = None) -&gt; None:     data = read_json(f\"../tests/data/input/{name}.json\")     input = shapely.geometry.shape(data)     output = shapely.geometry.shape(         antimeridian.fix_geojson(data, fix_winding=fix_winding)     )      if suptitle is None:         suptitle = name      figure = pyplot.figure()     figure.suptitle(suptitle)      axes = figure.add_subplot(2, 2, 1, projection=PlateCarree())     axes.set_title(\"Original in PlateCarree\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(input, crs=PlateCarree(), color=\"coral\", alpha=0.7)      axes = figure.add_subplot(2, 2, 2, projection=PlateCarree())     axes.set_title(\"Fixed in PlateCarree\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(output, crs=PlateCarree(), color=\"coral\", alpha=0.7)      axes = figure.add_subplot(2, 2, 3, projection=Mollweide(central_longitude=180))     axes.set_title(\"Original in Mollweide\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(input, crs=PlateCarree(), color=\"coral\", alpha=0.7)      axes = figure.add_subplot(2, 2, 4, projection=Mollweide(central_longitude=180))     axes.set_title(\"Fixed in Mollweide\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(output, crs=PlateCarree(), color=\"coral\", alpha=0.7)      pyplot.show()   for name in [     \"split\",     \"north-pole\",     \"complex-split\",     \"multi-split\",     \"overlap\", ]:     plot(name) In\u00a0[2]: Copied! <pre>plot(\"cw-split\", fix_winding=True, suptitle=\"Fix winding\")\nplot(\"cw-split\", fix_winding=False, suptitle=\"No fix winding\")\n</pre> plot(\"cw-split\", fix_winding=True, suptitle=\"Fix winding\") plot(\"cw-split\", fix_winding=False, suptitle=\"No fix winding\") <pre>/Users/gadomski/Code/gadomski/antimeridian/src/antimeridian/_implementation.py:594: FixWindingWarning: The exterior ring of this shape is wound clockwise. Since this is a common error in real-world geometries, this package is reversing the exterior coordinates of the input shape before running its algorithm. If you know that your input shape is correct (i.e. if your data encompasses both poles), pass `fix_winding=False`.\n  FixWindingWarning.warn()\n</pre>"},{"location":"examples/#examples","title":"Examples\u00b6","text":"<p>Here's some examples of using the antimeridian package on some artificial and real-world data.</p>"},{"location":"examples/#test-cases","title":"Test cases\u00b6","text":"<p>Our test suite exercises the antimeridian algorithm in a variety of ways. Here, we visualize some our test cases in two projections.</p>"},{"location":"examples/#winding-order","title":"Winding order\u00b6","text":"<p>The exterior ring of a GeoJSON Polygon should be wound counter-clockwise. Taken literally, this means that a clockwise-wound polygon would be a hole in a large polygon that encloses both poles. However, in practice, it is common for polygons to be wound incorrectly (e.g. #29 and #32). Our package therefore defaults to correcting the winding order to be counter-clockwise, and only creates these pole-encompassing polygons if explicitly asked.</p> <p>Most GIS software will automatically fix clockwise exterior polygons, and so it can be hard to know if your Polygon is wound correctly without inspecting the points themselves.</p>"},{"location":"failure-modes/","title":"Failure modes","text":"In\u00a0[1]: Copied! <pre>import json\nfrom pathlib import Path\nfrom typing import Any, Dict\n\nfrom cartopy.crs import PlateCarree, RotatedPole\nfrom matplotlib import pyplot\n\n\ndef read_example(name: str) -&gt; Dict[str, Any]:\n    with open(Path(\"examples\") / f\"{name}.json\") as f:\n        return json.load(f)\n\n\ndata = read_example(\"S3A_SL_2_LST_20160521T015552_20160521T033651_6059_004_217_____\")\nx = list()\ny = list()\nfor point in data[\"geometry\"][\"coordinates\"][0]:\n    x.append(point[0])\n    y.append(point[1])\n\nrotated_pole = RotatedPole(pole_latitude=37.5, pole_longitude=177.5)\nplate_carree = PlateCarree()\naxes = pyplot.axes(projection=rotated_pole)\naxes.set_title(\"S3A_SL_2_LST_20160521T015552_20160521T033651_6059_004_217_____\")\naxes.coastlines()\naxes.gridlines()\naxes.plot(x, y, marker=\"o\", transform=plate_carree)\naxes.set_xlim(-90, 90)\npyplot.show()\n</pre> import json from pathlib import Path from typing import Any, Dict  from cartopy.crs import PlateCarree, RotatedPole from matplotlib import pyplot   def read_example(name: str) -&gt; Dict[str, Any]:     with open(Path(\"examples\") / f\"{name}.json\") as f:         return json.load(f)   data = read_example(\"S3A_SL_2_LST_20160521T015552_20160521T033651_6059_004_217_____\") x = list() y = list() for point in data[\"geometry\"][\"coordinates\"][0]:     x.append(point[0])     y.append(point[1])  rotated_pole = RotatedPole(pole_latitude=37.5, pole_longitude=177.5) plate_carree = PlateCarree() axes = pyplot.axes(projection=rotated_pole) axes.set_title(\"S3A_SL_2_LST_20160521T015552_20160521T033651_6059_004_217_____\") axes.coastlines() axes.gridlines() axes.plot(x, y, marker=\"o\", transform=plate_carree) axes.set_xlim(-90, 90) pyplot.show() In\u00a0[2]: Copied! <pre>import shapely.geometry\nfrom cartopy.crs import Mollweide, PlateCarree\nfrom shapely.geometry import MultiPolygon, Polygon\n\nimport antimeridian\n\n\ndef plot(input: Polygon, output: Polygon | MultiPolygon, name: str) -&gt; None:\n    figure = pyplot.figure()\n    figure.suptitle(name)\n\n    axes = figure.add_subplot(2, 2, 1, projection=PlateCarree())\n    axes.set_title(\"Original in PlateCarree\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(input, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n    axes = figure.add_subplot(2, 2, 2, projection=PlateCarree())\n    axes.set_title(\"Fixed in PlateCarree\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(output, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n    axes = figure.add_subplot(2, 2, 3, projection=Mollweide(central_longitude=180))\n    axes.set_title(\"Original in Mollweide\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(input, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n    axes = figure.add_subplot(2, 2, 4, projection=Mollweide(central_longitude=180))\n    axes.set_title(\"Fixed in Mollweide\")\n    axes.stock_img()\n    axes.coastlines()\n    axes.add_geometries(output, crs=PlateCarree(), color=\"coral\", alpha=0.7)\n\n    pyplot.show()\n\n\ninput = shapely.geometry.shape(data[\"geometry\"])\noutput = shapely.geometry.shape(antimeridian.fix_geojson(data[\"geometry\"]))\nplot(input, output, \"S3A_SL_2_LST_20160521T015552_20160521T033651_6059_004_217_____\")\n</pre> import shapely.geometry from cartopy.crs import Mollweide, PlateCarree from shapely.geometry import MultiPolygon, Polygon  import antimeridian   def plot(input: Polygon, output: Polygon | MultiPolygon, name: str) -&gt; None:     figure = pyplot.figure()     figure.suptitle(name)      axes = figure.add_subplot(2, 2, 1, projection=PlateCarree())     axes.set_title(\"Original in PlateCarree\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(input, crs=PlateCarree(), color=\"coral\", alpha=0.7)      axes = figure.add_subplot(2, 2, 2, projection=PlateCarree())     axes.set_title(\"Fixed in PlateCarree\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(output, crs=PlateCarree(), color=\"coral\", alpha=0.7)      axes = figure.add_subplot(2, 2, 3, projection=Mollweide(central_longitude=180))     axes.set_title(\"Original in Mollweide\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(input, crs=PlateCarree(), color=\"coral\", alpha=0.7)      axes = figure.add_subplot(2, 2, 4, projection=Mollweide(central_longitude=180))     axes.set_title(\"Fixed in Mollweide\")     axes.stock_img()     axes.coastlines()     axes.add_geometries(output, crs=PlateCarree(), color=\"coral\", alpha=0.7)      pyplot.show()   input = shapely.geometry.shape(data[\"geometry\"]) output = shapely.geometry.shape(antimeridian.fix_geojson(data[\"geometry\"])) plot(input, output, \"S3A_SL_2_LST_20160521T015552_20160521T033651_6059_004_217_____\") In\u00a0[\u00a0]: Copied! <pre>output = shapely.geometry.shape(\n    antimeridian.fix_geojson(data[\"geometry\"], force_north_pole=True)\n)\nplot(\n    input,\n    output,\n    \"S3A_SL_2_LST_20160521T015552_20160521T033651_6059_004_217_____\\n\"\n    \"(forced north pole)\",\n)\n</pre> output = shapely.geometry.shape(     antimeridian.fix_geojson(data[\"geometry\"], force_north_pole=True) ) plot(     input,     output,     \"S3A_SL_2_LST_20160521T015552_20160521T033651_6059_004_217_____\\n\"     \"(forced north pole)\", ) In\u00a0[\u00a0]: Copied! <pre>data = read_example(\"S3A_SL_2_LST_20160521T033651_20160521T051750_6059_004_218_____\")\ninput = shapely.geometry.shape(data[\"geometry\"])\noutput = shapely.geometry.shape(\n    antimeridian.fix_geojson(data[\"geometry\"], force_north_pole=True)\n).buffer(0)\nplot(\n    input,\n    output,\n    \"S3A_SL_2_LST_20160521T033651_20160521T051750_6059_004_218_____\\n\"\n    \"(forced north pole)\",\n)\n</pre> data = read_example(\"S3A_SL_2_LST_20160521T033651_20160521T051750_6059_004_218_____\") input = shapely.geometry.shape(data[\"geometry\"]) output = shapely.geometry.shape(     antimeridian.fix_geojson(data[\"geometry\"], force_north_pole=True) ).buffer(0) plot(     input,     output,     \"S3A_SL_2_LST_20160521T033651_20160521T051750_6059_004_218_____\\n\"     \"(forced north pole)\", ) <p>In this case, you're better off not using the antimeridian package at all, but instead using shapely's buffer(0) fixer. You lose the pole coverage, but at least your geometry is close to what you want:</p> In\u00a0[5]: Copied! <pre>input = shapely.geometry.shape(data[\"geometry\"])\noutput = input.buffer(0)\nplot(\n    input,\n    output,\n    \"S3A_SL_2_LST_20160521T033651_20160521T051750_6059_004_218_____\\n(buffer(0))\",\n)\n</pre> input = shapely.geometry.shape(data[\"geometry\"]) output = input.buffer(0) plot(     input,     output,     \"S3A_SL_2_LST_20160521T033651_20160521T051750_6059_004_218_____\\n(buffer(0))\", )"},{"location":"failure-modes/#failure-modes","title":"Failure modes\u00b6","text":"<p>Our algorithm doesn't always work. It breaks down when a geometry's edge comes very close to a pole, which usually means the GeoJSON geometry is especially strange. Here's one real-world example from a Sentinel 3 STAC Item:</p>"},{"location":"failure-modes/#whats-an-algorithm-to-do","title":"What's an algorithm to do?\u00b6","text":"<p>Our normal algorithm can't handle this strange geometry:</p>"},{"location":"failure-modes/#force-the-geometry-over-the-north-pole","title":"Force the geometry over the north pole\u00b6","text":"<p>In some cases, we can use our priors to help the algorithm out. Here, we can force our fixer to extend the geometry over the north pole, which provides a better result:</p>"},{"location":"failure-modes/#it-doesnt-always-work","title":"It doesn't always work\u00b6","text":"<p>Some geometries are so bad that even our north pole hack doesn't produce a valid result:</p>"},{"location":"failure-modes/#conclusions","title":"Conclusions\u00b6","text":"<p>It's a messy business, dealing with these improperly constructed GeoJSON geometries. There's probably not going to be one solution that works for every case.</p>"},{"location":"the-algorithm/","title":"The algorithm","text":"<p>What follows is a walkthrough, with visual aids, of the algorithm underlying this package.</p>"},{"location":"the-algorithm/#background","title":"Background","text":"<p>Let's start with a simple GeoJSON geometry that doesn't come anywhere near the antimeridian. For the sake of example, let's say it runs from 40\u00b0 longitude west to 40\u00b0 east, and from 20\u00b0 latitude south to 20\u00b0 north. Its lower left point is at <code>-40, -20</code>, and its upper right point is at <code>40, 20</code>.</p> <p></p> <p>Now let's consider the same geometry, but shifted east 180 degrees. Its lower-left point is <code>140, -20</code>, and its upper-right point is at <code>220, 20</code>. Here's its representation in GeoJSON:</p> <pre><code>{\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n        [\n            [\n                140,\n                -20\n            ],\n            [\n                220,\n                -20\n            ],\n            [\n                220,\n                20\n            ],\n            [\n                140,\n                20\n            ],\n            [\n                140,\n                -20\n            ]\n        ]\n    ]\n}\n</code></pre> <p>And visualized:</p> <p></p> <p>So far, good enough. However, the bounds of WGS84, the coordinate system used by GeoJSON, go from -180\u00b0 to 180\u00b0 longitude. This means that the upper-right coordinate of our antimeridian-crossing box should be \"wrapped\" to <code>-140, 20</code>:</p> <pre><code>{\n    \"type\": \"Polygon\",\n    \"coordinates\": [\n        [\n            [\n                140,\n                -20\n            ],\n            [\n                -140,\n                -20\n            ],\n            [\n                -140,\n                20\n            ],\n            [\n                140,\n                20\n            ],\n            [\n                140,\n                -20\n            ]\n        ]\n    ]\n}\n</code></pre> <p>Let's consider the four points of our \"wrapped\" box, and the order in which they're connected:</p> <pre><code>    1              2              3            4            1\n\n[140, -20] -&gt; [-140, -20] -&gt; [-140, 20] -&gt; [140, 20] -&gt; [140, 20]\n</code></pre> <p>Exterior rings in GeoJSON should be wound counter-clockwise, but you can see that our antimeridian-crossing box appears to be wound clockwise.</p> <p></p> <p>This leads to a confusing situation \u2014 because it's invalid GeoJSON! You should not have a standalone clockwise ring. When rendering this polygon, some systems automatically correct the winding order, and would display this shape centered on the prime meridian. Another interpretation is that the shape is a hole, and the shell is the entire rest of the globe. This is very rarely what you're actually trying to represent.</p> <p></p> <p>Our algorithm can take this invalid GeoJSON as input and produce valid GeoJSON as output.</p>"},{"location":"the-algorithm/#segmentation","title":"Segmentation","text":"<p>To correct the invalid GeoJSON, we break our polygon into segments. To create segments, we start at the first point of the geometry, and walk through the points until we find a longitude jump of more than 180\u00b0 degrees.</p> <p></p> <p>When we find such a jump, we split the polygon into segments by inserting two points, one on each antimeridian. The first point ends the first segment, and the second point starts the second segment.</p> <p></p> <p>We then continue walking through the points, applying the same procedure when other jumps of 180\u00b0 longitude are found.</p> <p></p> <p>We then finish walking the points.</p> <p></p> <p>Because the last point of a GeoJSON Polygon's coordinates is the same as the first point, we join the first and the last segments.</p> <p></p> <p>We now use our segments to build new polygons. Let's consider the segment on the 180\u00b0 antimeridian. We take that segment's end point and search up the antimeridian for the first segment start point, joining those points to create a closed shape:</p> <p></p> <p>We use the same approach for the -180\u00b0 antimeridian, but search down (towards the south pole) instead of up.</p> <p>After the segments are joined, the individual Polygon are combined into a MultiPolygon. This conforms to the GeoJSON specification, which expects antimeridian-crossing polygons to be split into multipolygons at  the antimeridian.</p> <p></p>"},{"location":"the-algorithm/#complicated-segmentation","title":"Complicated segmentation","text":"<p>Note that this segmentation approach works even in more complicated cases, e.g. if there's a \"hole\" (like a donut over the antimeridian):</p> <p></p>"},{"location":"the-algorithm/#the-poles","title":"The poles","text":"<p>Geometries that overlap the north or the south pole present a related, but different, problem. Here's a oval geometry that covers the north pole, as visualized from \"above\" the earth:</p> <p></p> <p>That geometry would be represented as a set of points, all with positive latitudes and with longitudes covering more-or-less the entire -180\u00b0 to 180\u00b0 extent of our coordinate system. Because the edge of our geometry does not touch the pole, there's no point that has a 90\u00b0 latitude. This means that the geometry never touches the north pole in a cartesian visualization, since the maximum latitude of the geometry is less than 90\u00b0.</p> <p></p> <p>We use the same segmentation algorithm as described above, which in this case produces only a single segment.</p> <p></p> <p>When we try to close our polygon by searching \"up\" the 180\u00b0 antimeridian from our end point, there's no start point to find. So we create two new points, one on each antimeridian, and then continue the search down the other side. Here's that drawn out, step-by-step.</p> <p>First, we search up the antimeridian and find no points.</p> <p></p> <p>We add two points, one at the top of each antimeridian, and add them to the segment.</p> <p></p> <p>Finally, we search down the 180\u00b0 antimeridian until we find our segment start point.</p> <p></p> <p>This produces a single valid GeoJSON polygon that encloses the pole in a cartesian visualization.</p> <p></p>"}]}